import{_ as O,a as v}from"./client-CCeUhWoO.js";const s={RSC_START:0,RSC_CHUNK:1,RSC_END:2,ACTION_REQUEST:3,ACTION_START:4,ACTION_CHUNK:5,ACTION_END:6,ACTION_ERROR:7},E=new TextEncoder,T=new TextDecoder,a=36;function D(r){switch(r.type){case s.ACTION_REQUEST:{const t=r,n=JSON.stringify({id:t.id,args:t.args,requestId:t.requestId,clientUrl:t.clientUrl}),e=E.encode(n),o=new Uint8Array(1+e.length);return o[0]=t.type,o.set(e,1),o}case s.ACTION_START:case s.RSC_START:{const t=r,n=E.encode(t.id);if(n.length!==a)throw new Error("Invalid message ID length for START message");const e=new Uint8Array(3+a),o=new DataView(e.buffer);return o.setUint8(0,t.type),o.setUint16(1,t.status,!1),e.set(n,3),e}case s.ACTION_CHUNK:case s.RSC_CHUNK:{const t=r,n=E.encode(t.id);if(n.length!==a)throw new Error("Invalid message ID length for CHUNK message");const e=new Uint8Array(1+a+t.payload.length);return e[0]=t.type,e.set(n,1),e.set(t.payload,1+a),e}case s.ACTION_END:case s.RSC_END:{const t=r,n=E.encode(t.id);if(n.length!==a)throw new Error("Invalid message ID length for END message");const e=new Uint8Array(1+a);return e[0]=t.type,e.set(n,1),e}case s.ACTION_ERROR:{const t=r,n=E.encode(t.id);if(n.length!==a)throw new Error("Invalid message ID length for ERROR message");const e=JSON.stringify({error:t.error}),o=E.encode(e),c=new Uint8Array(1+a+o.length);return c[0]=t.type,c.set(n,1),c.set(o,1+a),c}default:throw new Error("Unknown message type for packing")}}function f(r){if(r.length===0)throw new Error("Cannot unpack empty message");const t=r[0];switch(t){case s.ACTION_REQUEST:{const n=T.decode(r.slice(1)),e=JSON.parse(n);return{type:t,...e}}case s.ACTION_START:case s.RSC_START:{if(r.length!==3+a)throw new Error("Invalid START message length");const e=new DataView(r.buffer).getUint16(1,!1),o=T.decode(r.slice(3));return{type:t,id:o,status:e}}case s.ACTION_CHUNK:case s.RSC_CHUNK:{if(r.length<1+a)throw new Error("Invalid CHUNK message length");const n=T.decode(r.slice(1,1+a)),e=r.slice(1+a);return{type:t,id:n,payload:e}}case s.ACTION_END:case s.RSC_END:{if(r.length!==1+a)throw new Error("Invalid END message length");const n=T.decode(r.slice(1,1+a));return{type:t,id:n}}case s.ACTION_ERROR:{if(r.length<1+a)throw new Error("Invalid ERROR message length");const n=T.decode(r.slice(1,1+a)),e=T.decode(r.slice(1+a));let o="Unknown error";try{o=JSON.parse(e).error}catch{}return{type:t,id:n,error:o}}default:throw new Error(`Unknown message type for unpacking: ${t}`)}}const k="default",K=({key:r=k,handleResponse:t})=>n=>{let e=null,o=!1;const c=crypto.randomUUID(),l=new URL(window.location.href),d=l.protocol==="https:";l.protocol="",l.host="";const i=async()=>{if(e)return;const u=d?"wss":"ws";e=new WebSocket(`${u}://${window.location.host}/__realtime?key=${encodeURIComponent(r)}&url=${encodeURIComponent(l.toString())}&clientId=${encodeURIComponent(c)}&shouldForwardResponses=${encodeURIComponent(t?"true":"false")}`),e.binaryType="arraybuffer",e.addEventListener("open",()=>{o=!0}),e.addEventListener("error",p=>{console.error("[Realtime] WebSocket error",p)}),e.addEventListener("close",()=>{console.warn("[Realtime] WebSocket closed, attempting to reconnect..."),e=null,o=!1,setTimeout(i,5e3)}),L(e,p=>{N(p)})},R=()=>{if(!e&&o)throw new Error("Inconsistent state: WebSocket is null but marked as connected");if(!e||!o)throw new Error("WebSocket is not connected");return e},w=async(u,p)=>{try{const y=R(),{encodeReply:g}=await O(async()=>{const{encodeReply:U}=await import("./client-CCeUhWoO.js").then(A=>A.c);return{encodeReply:U}},[]),m=new URL(window.location.href);m.protocol="",m.host="";const h=p!=null?await g(p):null,C=crypto.randomUUID(),I=D({type:s.ACTION_REQUEST,id:u,args:h,requestId:C,clientUrl:m.toString()}),S=b(C,y);return y.send(I),await N(await S)}catch(y){return console.error("[Realtime] Error calling server",y),null}},N=async u=>{try{let p,y=!0;if(n.handleResponse){const[m,h]=u.body.tee(),C=new Response(m,u);p=h,y=n.handleResponse(C)}else p=u.body;if(!y)return null;const g=v.createFromReadableStream(p,{callServer:w});return n.setRscPayload(g),(await g).actionResult}catch(p){throw p}};return i(),w};function b(r,t){const n={start:s.ACTION_START,chunk:s.ACTION_CHUNK,end:s.ACTION_END,error:s.ACTION_ERROR};return new Promise((e,o)=>{const c=l=>{const d=f(new Uint8Array(l.data));if(d.type!==s.ACTION_REQUEST&&d.id===r&&d.type===n.start){const i=d;t.removeEventListener("message",c);const R=_(r,t,n,o),w=new Response(R,{status:i.status,headers:{"Content-Type":"text/plain"}});e(w)}};t.addEventListener("message",c)})}function L(r,t){const n={start:s.RSC_START,chunk:s.RSC_CHUNK,end:s.RSC_END},e=async o=>{const c=f(new Uint8Array(o.data));if(!(c.type===s.ACTION_REQUEST||c.type===s.ACTION_CHUNK||c.type===s.ACTION_END||c.type===s.ACTION_ERROR)&&c.type===n.start){const l=c,d=_(l.id,r,n,R=>{console.error("[Realtime] Error creating update stream",R)}),i=new Response(d,{status:l.status,headers:{"Content-Type":"text/plain"}});t(i)}};r.addEventListener("message",e)}const _=(r,t,n,e)=>{let o=Promise.withResolvers();const c=new ReadableStream({start(d){o.resolve(d)}}),l=async d=>{const i=f(new Uint8Array(d.data));if(i.type===s.ACTION_REQUEST||i.id!==r)return;const R=await o.promise;if(i.type===n.chunk){const w=i;R.enqueue(w.payload)}else if(i.type===n.end)R.close(),t.removeEventListener("message",l);else if(n.error&&i.type===n.error){const w=i;e(new Error(w.error)),t.removeEventListener("message",l)}};return t.addEventListener("message",l),c};export{K as realtimeTransport};
//# sourceMappingURL=client-CjWApeFf.js.map
